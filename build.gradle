description = "A research library for graph processing"
group = "software.uncharted"
version = "0.1-SNAPSHOT"

apply plugin: 'scala'
apply plugin: 'maven'
apply plugin: 'distribution'
apply plugin: 'idea'

// Gradle/intellij don't work properly together with 1.8
sourceCompatibility = '1.7'

// maven repositories
repositories {
	mavenCentral()
	mavenLocal()
	maven {
		url = "https://repository.cloudera.com/artifactory/cloudera-repos"
	}
}

// shared version variables
ext {
	dependencyScalaVersion = "2.10"
	scalaVersion = "2.10.6"
	sparkVersion = "1.5.0-cdh5.5.2"
	hbaseVersion = "1.0.0-cdh5.5.2"
	htraceVersion = "3.2.0-incubating"

	// A shared function that adds hbase dependencies to the supplied project based on the build type.
	// We can't use the DSL in this context, so we have to go through the lower level DependencyManager APIs.
	addHBaseDependencies = { config ->
		if (config == null || config == "") {
			config = "compile"
		}
		getDependencies().add(config, "org.apache.hbase:hbase-common:$hbaseVersion", {
			exclude group: "asm", module: "asm"
			exclude group: "org.slf4j", module: "slf4j-api"
			exclude group: "org.slf4j", module: "slf4j-log4j12"
			exclude group: "org.jboss.netty", module: "netty"
			exclude group: "io.netty", module: "netty"
		})
		getDependencies().add(config, "org.apache.hbase:hbase-client:$hbaseVersion", {
			exclude group: "asm", module: "asm"
			exclude group: "org.slf4j", module: "slf4j-api"
			exclude group: "org.slf4j", module: "slf4j-log4j12"
			exclude group: "org.jboss.netty", module: "netty"
			exclude group: "io.netty", module: "netty"
		})
		getDependencies().add(config, "org.apache.hbase:hbase-server:$hbaseVersion", {
			exclude group: "asm", module: "asm"
			exclude group: "org.slf4j", module: "slf4j-api"
			exclude group: "org.slf4j", module: "slf4j-log4j12"
			exclude group: "org.mortbay.jetty", module: "servlet-api-2.5"
			exclude group: "org.jboss.netty", module: "netty"
			exclude group: "io.netty", module: "netty"
		})
		getDependencies().add(config, "org.apache.htrace:htrace-core:$htraceVersion", {
			exclude group: "asm", module: "asm"
			exclude group: "org.slf4j", module: "slf4j-api"
			exclude group: "org.slf4j", module: "slf4j-log4j12"
			exclude group: "org.mortbay.jetty", module: "servlet-api-2.5"
			exclude group: "org.jboss.netty", module: "netty"
			exclude group: "io.netty", module: "netty"
		})
	}
}

// appends scala test functionality to the baseline test task
test << {
	ant.taskdef(name: 'scalatest', classname: 'org.scalatest.tools.ScalaTestAntTask', classpath: classpath.asPath) {
            jvmarg = '-Dfile.encoding=UTF-8'
        }
	ant.scalatest(runpath: testClassesDir, haltonfailure: 'true', fork: 'false') {
		reporter(type: 'file', filename: 'test-output')
    tagsToExclude {
      's3.test' // disable s3 tests by default since it requires valid credentials
    }
	}
}

task wrapper(type: Wrapper) {
  gradleVersion = '2.4'
}

// Configure a jar task to build a fat jar that includes dependencies added ot the assemblyJarReq config.
task assemblyJar(type: Jar) {
	classifier = "assembly"
	from files(sourceSets.main.output.classesDir)
	from files(sourceSets.main.output.resourcesDir)
	from {
		configurations.assemblyJarDepends.collect {
			it.isDirectory() ? it : zipTree(it)
		}
	}
}
assemblyJar.mustRunAfter "jar"
assemble.dependsOn "assemblyJar"

configurations {
	// IntelliJ does something funky when resolving conflicting jars - we need to force the exclusion
	// below in order to run test cases from within IntelliJ.  Command line is fine.
	compile.exclude group: "org.jboss.netty", module: "netty"
	compile.exclude group: "org.apache.hadoop", module: "hadoop-client"

	// Create a configuration to hold jars that we need to roll into our fat jar.  Disable transitive dependency
	// resolution, since we only want the jars we specifically list.
	assemblyJarDepends {
		transitive = false
	}

	provided
	compile.extendsFrom provided

	dist
}

// Generate the assembly jar along with the build artifacts
artifacts {
	dist assemblyJar
}

// Jars / projects this project depends on.
dependencies {
	compile project(":salt")
	compile project(":sparkpipe-core")
	compile project(":sparkpipe-salt-ops")

	// Compile config - needed to build
	compile "org.apache.spark:spark-core_$dependencyScalaVersion:$sparkVersion"
	compile "org.apache.spark:spark-yarn_$dependencyScalaVersion:$sparkVersion"
	compile "org.apache.spark:spark-sql_$dependencyScalaVersion:$sparkVersion"
	compile "org.apache.spark:spark-mllib_$dependencyScalaVersion:$sparkVersion"
	compile "com.databricks:spark-csv_$dependencyScalaVersion:1.3.0"
  compile "com.amazonaws:aws-java-sdk:1.3.11"
	compile "org.clapper:grizzled-slf4j_2.10:1.0.2"
	addHBaseDependencies()

	provided "org.apache.spark:spark-mllib_$dependencyScalaVersion:$sparkVersion"

	testCompile "org.scalatest:scalatest_$dependencyScalaVersion:2.2.5"

	assemblyJarDepends project(":salt")
	assemblyJarDepends project(":sparkpipe-core")
	assemblyJarDepends project(":sparkpipe-salt-ops")
	assemblyJarDepends "com.databricks:spark-csv_$dependencyScalaVersion:1.3.0"
	assemblyJarDepends "org.apache.commons:commons-csv:1.1"
	assemblyJarDepends "com.univocity:univocity-parsers:1.5.1"
	addHBaseDependencies("assemblyJarDepends")
}

// Creation of a distribution jar
distributions {
	main {
		baseName = 'xdata-graph'
		contents {
			// Copy the run scripts over
			into ("scripts"){
				from("src/scripts")
				fileMode 0755
			}

			// Copy assembly jar, stripping off the version info.
			into("lib") {
				from configurations.dist.artifacts.files.filter {
					it.name =~ /assembly\w*\.jar/
				}
				rename "(.*)-$version-assembly(.*)", "\$1\$2"
			}
		}
	}
}
